# 2025-12-01: copied from .prior-work-files/lib/fun/cleanlib
# 2025-12-14: updated to manage zsh / bash diffs (further cleanup expected)
# 2025-12-16: TODO: debug_on display statements need work for function stacks shorter than 3
debug ()
{
    return
}
debug_off ()
{
    : no diagnostics, redefine debug to just return;
    : date: 2023-03-29;
    : date: 2024-11-05;
    : date: 2025-12-14: copyedits;
    debug () { return; }
}
debug_on ()
{
    : write a COMMENT, on STDERR, at a point in a function, listing ...;
    : the CALLER and any passed ARGS, who CALLED it, 3rd, and that CALLER, 4th as well;
    : lesson: NO user functions in DEBUG:;
    : date: 2022-03-07;
    : date: 2023-01-30;
    : date: 2024-11-05;
    : date: 2025-12-14: zsh / bash differences;
    if [[ -n $ZSH_VERSION ]]; then
        debug () { printf "%-21s\t%-21s\t%-21s : %s\n" ${funcstack[4]} ${funcstack[3]} ${funcstack[2]} "$*" 1>&2 }
    elif [[ -n $BASH_VERSION ]]; then
        debug () { printf \"%-21s\\t%-21s\\t%-21s : %s\\n\" \${FUNCNAME[3]} \${FUNCNAME[2]} \${FUNCNAME[1]} \"\$*\" 1>&2; }
    else
        echo "unsupported shell: no debug functions defined"
    fi
}
pause ()
{
    return
}
pause_off ()
{
    : do not pause, redefine pause to just return;
    : date: 2025-12-15;
    pause () { return; }
}
pause_on ()
{
    : pause the script, wait for user CR/CTRL-C;
    : date: 2023-01-30;
    : date: 2024-11-05;
    : date: 2025-12-15: zsh / bash differences;
    if in_zsh; then
       pause () { read "?[return] / [Ctrl-C] ${funcstack[2]} $@ ? " < /dev/tty; }
    elif in_bash; then
       pause () { read -p "[return] / [Ctrl-C] ${FUNCNAME[1]} $@ ? " < /dev/tty; }
    else
       echo "unsupported shell - use zsh or bash"
    fi
}
#
# copied from .prior-work-files/lib/fun/cleanlib
namedfiles ()
{
    : the ordinary file arguments, default is current directory;
    : revised from a version that ignored ~;
    : lesson: hide Error reminders behind a debug;
    : date: 2023-07-22;
    : date: 2024-04-30;
    : date: 2024-06-26;
    debug ENTRY $# $@;
    pause;
    local err=~/tmp/.file.err;
    set -- ${@:-$(ls -a)};
    debug SET $PWD, $# $@;
    pause;
    for file in $*;
    do
        debug file: $file;
        debug Errors are thrown into $err;
        [[ -f $file ]] && echo $file;
    done 2> $err
}
#
# 2025-12-13: copied from .prior-work-file/lib/fun/programlib
report_notargcount ()
{
    : report an insufficient number of args from the calling function;
    : date: 2023-01-01;
    debug ENTRY $@;
    [[ $2 -ge $1 ]] && return 1;
    report_usage need at least $1 arg/s: ${*:3}
}
report_notfile () 
{ 
    : report the argument is not a File;
    : date: 2018-02-16;
    : date: 2022-01-08;
    [[ -f $1 ]] && return 1;
    report_usage $1 "ISN'T" a file;
    declare -f $(myname 2) 1>&2
}
report_usage () 
{ 
    : writes: usage message of report_... caller FAILURE to STDERR;
    : date: 2018-03-30;
    : date: 2022-04-29;
    : date: 2024-11-14;
    local caller=$(myname 3);
    : case $caller in;
    : diff_pair;
    : callStack;
    : read -p "HALT, use ctrl-C" < /dev/tty > /dev/tty;
    :;
    : esac;
    echo USAGE $caller: $* 1>&2
}
ignore () 
{ 
    : ~ cmmd args ...;
    : returns STATUS, but not STDOUT;
    : trace_callstack;
    : debug $*;
    : date: 2019-11-23;
    $@ > /dev/null
}
#
# 2025-12-13: copied from .prior-work-files/lib/fun/utillib
if_missingargs ()
{
    : returns the source of the calling function for any missing argumpents;
    : usage: ~ "{ Minimum Arg Count } $@";
    : date: 2023-07-10;
    : date: 2024-02-23;
    :;
    : ------- Save the Minimum Arg Count, shift to see the callers Args --;
    :;
    local shouldHave=$1;
    shift;
    : ---------------- demonstration use of debug, whose default is OFF --;
    :;
    debug "$#: $@";
    :;
    report_notargcount $shouldHave $# || return 1;
    declare -f $(myname 2);
    return
}
setenv ()
{
    : set the First ARG in the ENVironment to the value of the remaining;
    : related: setget;
    : date: 2023-08-02;
    : debug ENTRY $# $*;
    : date: 2024-04-29;
    if_missingargs 1 $* && return;
    local na=$1;
    : debug na: $na;
    shift;
    : debug ASSIGN $na=\"$*\";
    eval $na=\"$*\";
    export $na;
    : debug RETURN $na
}
timestamp ()
{
    : date: 2023-08-07;
    : debug ENTRY $# $@;
    report_notfile $1 && return 1;
    touch -t $(date -r $(epochmtime $1) +%Y%m%d%H%M.%S) $2
} 
# 2025-12-14: copied from .prior-work-files/lib/fun/utillib
epochmtime () 
{ 
    : mtime of a file in epoch seconds;
    : date: 2023-07-22;
    : date: 2025-12-14: rename for clarity;
    [[ -f $1 ]] || return;
    set $(stat -r $1);
    echo ${10}
}
#
# 2025-12-13: copied from ShellFunctions.md
fbdy () {
	declare -f ${@:-fbdy}
}
#
# 2025-12-14: copied from .prior-work-files/lib/fun/cleanlib
myname () 
{ 
    : a calling functions NAME, default MYcaller;
    : 2 is the callers caller, 3 is theirs, etc...;
    : date: 2023-07-22;
    : date: 2025-12-14: POSIX version, zsh / bash diffs;
    if [ -n "$ZSH_VERSION" ]; then
       local level=${1:-1}
       echo ${funcstack[$((level + 1))]}
    elif [ -n "$BASH_VERSION" ]; then
        echo ${FUNCNAME[${1:-1}]}
    else
	echo "unsupported shell - use zsh or bash"
    fi
}
# based on `foreach` from ".prior-work-files/lib/fun/cleanlib"
# 2025-12-03
apply () 
{ 
    : TCL legacy, FOREACH function Arg ...;
    : date: 2024-04-29;
    : date: 2025-12-20: rename foreach as apply, zsh keyword collision;
    [[ $# -lt 2 ]] && return;
    local cmd="$1"
    shift
    for arg in "$@"
    do
        $cmd "$arg"
    done
}
# 2025-12-13
# these functions will be needed
detect_shell() {
    if [ -n "$BASH_VERSION" ]; then
        echo "bash"
    elif [ -n "$ZSH_VERSION" ]; then
        echo "zsh"
    else
        echo "sh or unknown"
    fi
}
#
findfdef () {
    : date: 2025-12-13
    local dir="$(realpath ~/Documents/Github/bashlibs/.prior-work-files)"
    rg -l "$1\ \(\)" ${2:-$dir}
}
# 2025-12-14: claude.ai assisted
in_zsh() {
    [ -n "$ZSH_VERSION" ]
}
in_bash() {
    [ -n "$BASH_VERSION" ]
}
# usage:
# if in_zsh; then ... fi
# Or with && / ||
# in_zsh && echo "Running zsh" || echo "Not zsh"
