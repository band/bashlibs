# 2025-12-01: copied from .prior-work-files/lib/fun/cleanlib
# 
debug ()
{
    return
}
debug_off ()
{
    : no diagnostics, just return;
    : date: 2023-03-29;
    : date: 2024-11-05;
    function debug () 
    { 
        return
    }
}
debug_on ()
{
    : write a COMMENT, on STDERR, at a point in a function, listing ...;
    : the CALLER and any passed ARGS, who CALLED it, 3rd, and that CALLER, 4th as well;
    : lesson: NO user functions in DEBUG:;
    : date: 2022-03-07;
    : date: 2023-01-30;
    : date: 2024-11-05;
    eval "debug () { printf \"%-21s\\t%-21s\\t%-21s : %s\\n\" \${FUNCNAME[3]} \${FUNCNAME[2]} \${FUNCNAME[1]} \"\$*\" 1>&2; }"
}
pause ()
{
    return
}
pause_off ()
{
    : do not pause, just return;
    : date: 2023-03-29;
    : date: 2024-11-05;
    function pause () 
    { 
        return
    }
}
pause_on ()
{
    : pause the script, waiting for the users CR;
    : date: 2023-01-30;
    : date: 2024-11-05;
    eval "pause () { read -p \"[return] / [Ctrl-C] \${FUNCNAME[1]} \$@ ? \" < /dev/tty; }"
}
#
# copied from .prior-work-files/lib/fun/cleanlib
namedfiles ()
{
    : the ordinary file arguments, default is current directory;
    : revised from a version that ignored ~;
    : lesson: hide Error reminders behind a Debug;
    : date: 2023-07-22;
    : date: 2024-04-30;
    : date: 2024-06-26;
    debug ENTRY $# $@;
    pause;
    local err=~/tmp/.file.err;
    set -- ${@:-$(ls -a)};
    debug SET $PWD, $# $@;
    pause;
    for file in $*;
    do
        debug file: $file;
        debug Errors are thrown into $err;
        [[ -f $file ]] && echo $file;
    done 2> $err
}
#
# 2025-12-13: copied from .prior-work-file/lib/fun/programlib
report_notargcount ()
{
    : report an insufficient number of args from the calling function;
    : date: 2023-01-01;
    debug ENTRY $@;
    [[ $2 -ge $1 ]] && return 1;
    report_usage need at least $1 arg/s: ${*:3}
}
report_notfile () 
{ 
    : report the argument is not a File;
    : date: 2018-02-16;
    : date: 2022-01-08;
    [[ -f $1 ]] && return 1;
    report_usage $1 "ISN'T" a file;
    declare -f $(myname 2) 1>&2
}
report_usage () 
{ 
    : writes: usage message of report_... caller FAILURE to STDERR;
    : date: 2018-03-30;
    : date: 2022-04-29;
    : date: 2024-11-14;
    local caller=$(myname 3);
    : case $caller in;
    : diff_pair;
    : callStack;
    : read -p "HALT, use ctrl-C" < /dev/tty > /dev/tty;
    :;
    : esac;
    echo USAGE $caller: $* 1>&2
}
ignore () 
{ 
    : ~ cmmd args ...;
    : returns STATUS, but not STDOUT;
    : trace_callstack;
    : debug $*;
    : date: 2019-11-23;
    $@ > /dev/null
}
#
# 2025-12-13: copied from .prior-work-files/lib/fun/utillib
if_missingargs ()
{
    : returns the source of the calling function for any missing argumpents;
    : usage: ~ "{ Minimum Arg Count } $@";
    : date: 2023-07-10;
    : date: 2024-02-23;
    :;
    : ------- Save the Minimum Arg Count, shift to see the callers Args --;
    :;
    local shouldHave=$1;
    shift;
    : ---------------- demonstration use of debug, whose default is OFF --;
    :;
    debug "$#: $@";
    :;
    report_notargcount $shouldHave $# || return 1;
    declare -f $(myname 2);
    return
}
setenv ()
{
    : set the First ARG in the ENVironment to the value of the remaining;
    : related: setget;
    : date: 2023-08-02;
    : debug ENTRY $# $*;
    : date: 2024-04-29;
    if_missingargs 1 $* && return;
    local na=$1;
    : debug na: $na;
    shift;
    : debug ASSIGN $na=\"$*\";
    eval $na=\"$*\";
    export $na;
    : debug RETURN $na
}
timestamp ()
{
    : date: 2023-08-07;
    report_notfile $1 && return 1;
    touch -t $(date -r $(epoch $1) +%Y%m%d%H%M.%S) $2
} 
#
# 2025-12-13: copied from ShellFunctions.md
fbdy () {
	declare -f ${@:-fbdy}
}
#
# 2025-12-14: copied from .prior-work-files/lib/fun/cleanlib
myname () 
{ 
    : a calling functions NAME, default MYcaller;
    : 2 is the callers caller, 3 is theirs, etc...;
    : date: 2023-07-22;
    : date: 2025-12-14: POSIX version, zsh / bash diffs;
    if [ -n "$ZSH_VERSION" ]; then
       local level=${1:-1}
       echo ${funcstack[$((level + 1))]}
    elif [ -n "$BASH_VERSION" ]; then
        echo ${FUNCNAME[${1:-1}]}
    else
	echo "unsupported shell - use zsh or bash"
    fi
}

